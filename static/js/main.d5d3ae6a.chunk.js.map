{"version":3,"sources":["PathFindingVisualizer/Node/Node.jsx","Algorithms/Util.js","PathFindingVisualizer/PathFindingVisualizer.jsx","Algorithms/Dijkstra.js","Algorithms/DFS.js","Algorithms/BFS.js","App.js","serviceWorker.js","index.js"],"names":["Node","props","row","col","state","hover","this","grid","isStart","isEnd","isHoveringStart","isHoveringEnd","draggingWall","additionalClass","isWall","color","shortest","className","onMouseEnter","setState","onMouseLeave","onMouseDown","onMouseUp","Component","getNeighbors","neighbors","getValOrUndefined","length","undefined","push","filter","node","getShortestPath","endNode","path","currNode","parent","unshift","searchAlgorithms","dij","startNode","start","end","distance","unvisited","visited","shift","currDistance","dfs","stack","pop","forEach","neighbor","bfs","queue","initState","width","height","draggingStart","draggingEnd","PathFindingVisualizer","selectedAlgorithm","algo","getInitialGrid","data","val","Infinity","searchResult","i","setTimeout","console","log","newGrid","slice","animateSolution","walls","currNodes","createNode","inputRow","inputCol","startRow","startCol","endRow","endCol","onChange","target","value","Object","keys","map","key","onClick","executeSearch","reset","style","border","margin","marginTop","nodeRow","rowIdx","nodeCol","colIdx","getGrid","bind","mouseDown","mouseUp","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"8RAIqBA,G,wDACnB,WAAYC,GAAQ,IAAD,sBACjB,cAAMA,GADW,IAETC,EAAaD,EAAbC,IAAKC,EAAQF,EAARE,IAFI,OAGjB,EAAKC,MAAQ,CAAEF,MAAKC,MAAKE,OAAO,GAHf,E,qDAMT,IAAD,SAUHC,KAAKL,MARPC,EAFK,EAELA,IACAC,EAHK,EAGLA,IACAI,EAJK,EAILA,KACAC,EALK,EAKLA,QACAC,EANK,EAMLA,MACAC,EAPK,EAOLA,gBACAC,EARK,EAQLA,cACAC,EATK,EASLA,aAGEC,EAAkB,GA0CtB,OAvCIP,KAAKF,MAAMC,QACbQ,EAAkB,aAIhBL,IACFK,EAAkB,SAGhBJ,IACFI,EAAkB,OAIhBP,KAAKF,MAAMC,OAASK,IACtBG,EAAkB,SAIhBP,KAAKF,MAAMC,OAASM,IACtBE,EAAkB,OAGhBD,GAAgBN,KAAKF,MAAMC,QAC7BE,IAAOL,GAAKC,GAAKW,QAAS,GAGxBP,IAAOL,GAAKC,GAAKW,SACnBD,EAAkB,QAGhBN,IAAOL,GAAKC,GAAKY,QACnBF,EAAkB,WAGhBN,IAAOL,GAAKC,GAAKa,WACnBH,EAAkB,YAIlB,yBACEI,UAAS,eAAUJ,GACnBK,aAAc,kBAAM,EAAKC,SAAS,CAAEd,OAAO,KAC3Ce,aAAc,kBAAM,EAAKD,SAAS,CAAEd,OAAO,KAC3CgB,YAAa,kBAAM,EAAKpB,MAAMoB,YAAYnB,EAAKC,IAC/CmB,UAAW,kBAAM,EAAKrB,MAAMqB,UAAUpB,EAAKC,U,GAnEjBoB,c,OCJ3B,SAASC,EAAajB,EAAML,EAAKC,GACtC,IAAIsB,EAAY,GAEVC,EAAoB,SAACxB,EAAKC,GAAN,OACxBD,EAAM,GAAKA,GAAOK,EAAKoB,QAAUxB,EAAM,GAAKA,GAAOI,EAAK,GAAGoB,YACvDC,EACArB,EAAKL,GAAKC,IAOhB,OALAsB,EAAUI,KAAKH,EAAkBxB,EAAM,EAAGC,IAC1CsB,EAAUI,KAAKH,EAAkBxB,EAAM,EAAGC,IAC1CsB,EAAUI,KAAKH,EAAkBxB,EAAKC,EAAM,IAC5CsB,EAAUI,KAAKH,EAAkBxB,EAAKC,EAAM,IAErCsB,EAAUK,QAAO,SAAAC,GAAI,YAAaH,IAATG,KAG3B,SAASC,EAAgBzB,EAAM0B,GAIpC,IAHA,IAAIC,EAAO,GACPC,EAAW5B,EAAK0B,EAAQ/B,KAAK+B,EAAQ9B,UAEdyB,IAApBO,EAASC,QACdF,EAAKG,QAAQF,EAASC,QACtBD,EAAWA,EAASC,OAItB,OADAF,EAAKL,KAAKtB,EAAK0B,EAAQ/B,KAAK+B,EAAQ9B,MAC7B+B,ECnBT,IAAMI,EAAmB,CACvBC,ICNK,SAAsBC,EAAWP,EAAS1B,GAC/C,IAAMkC,EAAQlC,EAAKiC,EAAUtC,KAAKsC,EAAUrC,KACtCuC,EAAMnC,EAAK0B,EAAQ/B,KAAK+B,EAAQ9B,KACtCsC,EAAME,SAAW,EAKjB,IAHA,IAAIC,EAAY,CAACH,GACbI,EAAU,GAEPD,EAAUjB,OAAS,GAAG,CAC3B,IAAIQ,EAAWS,EAAUE,QAGzB,GAFAX,EAASU,SAAU,EACnBA,EAAQhB,KAAKM,GACTA,EAASjC,KAAOwC,EAAIxC,KAAOiC,EAAShC,KAAOuC,EAAIvC,IAAK,MAJ7B,oBAKVqB,EAAajB,EAAM4B,EAASjC,IAAKiC,EAAShC,MALhC,IAK3B,2BAAiE,CAAC,IAAzD4B,EAAwD,QAC/D,IAAIA,EAAKc,UAAWd,EAAKjB,OAAzB,CACA,IAAIiC,EAAeZ,EAASQ,SAAW,EACnCI,EAAehB,EAAKY,WACtBZ,EAAKK,OAASD,EACdJ,EAAKY,SAAWI,EAChBH,EAAUf,KAAKE,MAXQ,+BAe7B,MAAO,CACLG,KAAMF,EAAgBzB,EAAM0B,GAC5BY,YDlBFG,IEPK,SAAiBR,EAAWP,EAAS1B,GAC1C,IAAI0C,EAAQ,GACRJ,EAAU,GACdI,EAAMpB,KAAKtB,EAAKiC,EAAUtC,KAAKsC,EAAUrC,MAEzC,IALgD,iBAM9C,IAAIgC,EAAWc,EAAMC,MAGrB,GAFAf,EAASU,SAAU,EACnBA,EAAQhB,KAAKM,GACTA,EAASjC,KAAO+B,EAAQ/B,KAAOiC,EAAShC,KAAO8B,EAAQ9B,IAAK,cAChDqB,EAAajB,EAAM4B,EAASjC,IAAKiC,EAAShC,KAChDgD,SAAQ,SAAAC,GACXA,EAASP,SAAYO,EAAStC,SACjCsC,EAAShB,OAASD,EAClBc,EAAMpB,KAAKuB,QATVH,EAAMtB,OAAS,GAAG,kBAIyC,MAUlE,MAAO,CACLO,KAAMF,EAAgBzB,EAAM0B,GAC5BY,YFbFQ,IGRK,SAAiBb,EAAWP,EAAS1B,GAC1C,IAAIkC,EAAQlC,EAAKiC,EAAUtC,KAAKsC,EAAUrC,KAEtC0C,EAAU,GACVH,EAAMnC,EAAK0B,EAAQ/B,KAAK+B,EAAQ9B,KAChCmD,EAAQ,GACZA,EAAMzB,KAAKY,GAEX,IARgD,iBAS9C,IAAIN,EAAWmB,EAAMR,QAIrB,OAHAX,EAASU,SAAU,EACnBA,EAAQhB,KAAKM,GAETA,EAASrB,OAAQ,WACjBqB,EAASjC,KAAOwC,EAAIxC,KAAOiC,EAAShC,KAAOuC,EAAIvC,IAAK,aAEtCqB,EAAajB,EAAM4B,EAASjC,IAAKiC,EAAShC,KAElDgD,SAAQ,SAAAC,GACXA,EAASP,SAAYO,EAAStC,SACjCsC,EAAShB,OAASD,EAClBmB,EAAMzB,KAAKuB,QAbVE,EAAM3B,OAAS,GAAG,CAAC,IAAD,qCAMiC,MAY1D,MAAO,CACLO,KAAMF,EAAgBzB,EAAM0B,GAC5BY,aHlBEU,EAAY,CAChBC,MAAO,GACPC,OAAQ,GACRlD,KAAM,GACNmD,eAAe,EACfC,aAAa,EACb/C,cAAc,EACd4B,UAAW,CAAEtC,IAAK,EAAGC,IAAK,GAC1B8B,QAAS,CAAE/B,IAAK,EAAGC,IAAK,IAGLyD,E,kDACnB,WAAY3D,GAAQ,IAAD,8BACjB,cAAMA,IAEDuC,UAAYvC,EAAMuC,UACvB,EAAKP,QAAUhC,EAAMgC,QAErB,EAAK7B,MAAL,2BACKmD,GADL,IAEEM,kBAAmB5D,EAAM6D,OARV,E,gEAajB,IAAIvD,EAAOD,KAAKyD,eAAe,IAC/BzD,KAAKa,SAAS,CAAEZ,W,iCAGPyD,GACT,OAAO,2BACFA,GADL,IAEEC,IAAKD,EAAK9D,IAAM8D,EAAK7D,IACrB0C,SAAS,EACTF,SAAUuB,IACV9B,YAAQR,EACRpB,SAAS,EACTC,OAAO,M,gCAKT,OAAOH,KAAKF,MAAMG,O,sCAGJ4D,EAAc5D,GAC5B,IADmC,IAAD,kBACzB6D,GACPC,YAAW,WACTC,QAAQC,IAAI,UACZ,IAAIpC,EAAWgC,EAAajC,KAAKkC,GAC7BI,EAAUjE,EAAKkE,QACnBD,EAAQrC,EAASjC,KAAKiC,EAAShC,KAAKa,UAAW,EAC/C,EAAKG,SAAS,CAAEZ,KAAMiE,MACjB,GAAJJ,IAPIA,EAAI,EAAGA,EAAID,EAAajC,KAAKP,OAAQyC,IAAM,EAA3CA,K,oCAWGN,GAIZ,IAJmB,IAAD,SACiBxD,KAAKF,MAAlCG,EADY,EACZA,KAAMiC,EADM,EACNA,UAAWP,EADL,EACKA,QACnBkC,EAAe7B,EAAiBwB,GAAMtB,EAAWP,EAAS1B,GAF5C,WAIT6D,GACPC,YAAW,WACT,IAAIlC,EAAWgC,EAAatB,QAAQuB,GAChCI,EAAUjE,EAAKkE,QACnBD,EAAQrC,EAASjC,KAAKiC,EAAShC,KAAKY,OAAQ,EAC5C,EAAKI,SAAS,CAAEZ,KAAMiE,IAClBJ,IAAMD,EAAatB,QAAQlB,OAAS,GACtC,EAAK+C,gBAAgBP,EAAc5D,KAEhC,GAAJ6D,IATIA,EAAI,EAAGA,EAAID,EAAatB,QAAQlB,OAAQyC,IAAM,EAA9CA,K,qCAaIO,GAEb,IADA,IAAIpE,EAAO,GACFL,EAAM,EAAGA,EAAMI,KAAKF,MAAMoD,MAAOtD,IAAO,CAE/C,IADA,IAAI0E,EAAY,GACPzE,EAAM,EAAGA,EAAMG,KAAKF,MAAMqD,OAAQtD,IACzCyE,EAAU/C,KAAKvB,KAAKuE,WAAW,CAAE3E,MAAKC,SAExCI,EAAKsB,KAAK+C,GAEZ,OAAOrE,I,gCAGCuE,EAAUC,GAAW,IAAD,EACGzE,KAAKF,MAA5BoC,EADoB,EACpBA,UAAWP,EADS,EACTA,QACf6C,IAAatC,EAAUtC,KAAO6E,GAAYvC,EAAUrC,IACtDG,KAAKa,SAAS,CAAEuC,eAAe,IACtBoB,IAAa7C,EAAQ/B,KAAO6E,GAAY9C,EAAQ9B,IACzDG,KAAKa,SAAS,CAAEwC,aAAa,IAE7BrD,KAAKa,SAAS,CAAEP,cAAc,M,8BAI1BV,EAAKC,GAAM,IAAD,EACeG,KAAKF,MADpB,EACRoC,UADQ,EACGP,QACnB,GAAI3B,KAAKF,MAAMsD,cAAe,CAC5BpD,KAAKa,SAAS,CAAEuC,eAAe,IAC/B,IAAIlB,EAAY,CACdtC,MACAC,OAEFG,KAAKa,SAAS,CAAEqB,mBACX,GAAIlC,KAAKF,MAAMuD,YAAa,CACjCrD,KAAKa,SAAS,CAAEwC,aAAa,IAC7B,IAAI1B,EAAU,CACZ/B,MACAC,OAEFG,KAAKa,SAAS,CAAEc,iBAEhB3B,KAAKa,SAAS,CAAEP,cAAc,M,8BAKhC,IAAIL,EAAOD,KAAKyD,eAAe,IAC/BzD,KAAKa,SAAL,2BACKoC,GADL,IAEEhD,OACAsD,kBAAmBvD,KAAKF,MAAMyD,uB,+BAIxB,IAAD,SACwBvD,KAAKF,MAA5BoC,EADD,EACCA,UAAWP,EADZ,EACYA,QAEb+C,EAAWxC,EAAUtC,IACrB+E,EAAWzC,EAAUrC,IACrB+E,EAASjD,EAAQ/B,IACjBiF,EAASlD,EAAQ9B,IAEvB,OACE,6BACE,4BACEiF,SAAU,SAAAvB,GACR,EAAK1C,SAAS,CACZ0C,kBAAmBA,EAAkBwB,OAAOC,SAGhDA,MAAOhF,KAAKF,MAAMyD,mBAEjB0B,OAAOC,KAAKlD,GAAkBmD,KAAI,SAAAC,GACjC,OAAO,4BAAQJ,MAAOI,GAAMA,OAGhC,4BACEC,QAAS,kBAAM,EAAKC,cAAc,EAAKxF,MAAMyD,qBAD/C,kBAKA,4BAAQ8B,QAAS,kBAAM,EAAKE,UAA5B,SACA,yBACEC,MAAO,CACLtC,MAAO,IACPC,OAAQ,IACRsC,OAAQ,kBACRC,OAAQ,WACRC,UAAW,SAGZ3F,KAAKF,MAAMG,KAAKkF,KAAI,SAACS,EAASC,GAC7B,OAAOD,EAAQT,KAAI,SAACW,EAASC,GAC3B,OACE,6BACE,kBAAC,EAAD,CACEnG,IAAKiG,EACLT,IAAKS,EAASE,EACdlG,IAAKkG,EACL9F,KAAM,EAAK+F,QAAQC,KAAK,GACxBlF,YAAa,EAAKmF,UAAUD,KAAK,GACjCjF,UAAW,EAAKmF,QAAQF,KAAK,GAC7B/F,QAASwE,IAAamB,GAAUlB,IAAaoB,EAC7C5F,MAAOyE,IAAWiB,GAAUhB,IAAWkB,EACvC3F,gBAAiB,EAAKN,MAAMsD,cAC5B/C,cAAe,EAAKP,MAAMuD,YAC1B/C,aAAc,EAAKR,MAAMQ,eACxB,iB,GAzK8BW,aIXpCmF,MARf,WACE,OACE,yBAAKzF,UAAU,OACb,kBAAC,EAAD,CAAuBuB,UAAW,EAAGP,QAAS,EAAG6B,KAAM,UCKzC6C,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,SD2H3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,MAAK,SAAAC,GACjCA,EAAaC,kB","file":"static/js/main.d5d3ae6a.chunk.js","sourcesContent":["import React, { Component } from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  constructor(props) {\n    super(props);\n    const { row, col } = props;\n    this.state = { row, col, hover: false };\n  }\n\n  render() {\n    const {\n      row,\n      col,\n      grid,\n      isStart,\n      isEnd,\n      isHoveringStart,\n      isHoveringEnd,\n      draggingWall\n    } = this.props;\n\n    let additionalClass = '';\n\n    // Toggling hover interaction styling\n    if (this.state.hover) {\n      additionalClass = 'hovering ';\n    }\n\n    // Adding static styling to start node\n    if (isStart) {\n      additionalClass = 'start';\n    }\n\n    if (isEnd) {\n      additionalClass = 'end';\n    }\n\n    // We are moving the start node\n    if (this.state.hover && isHoveringStart) {\n      additionalClass = 'start';\n    }\n\n    // We are moving the end node\n    if (this.state.hover && isHoveringEnd) {\n      additionalClass = 'end';\n    }\n\n    if (draggingWall && this.state.hover) {\n      grid()[row][col].isWall = true;\n    }\n\n    if (grid()[row][col].isWall) {\n      additionalClass = 'wall';\n    }\n\n    if (grid()[row][col].color) {\n      additionalClass = 'visited';\n    }\n\n    if (grid()[row][col].shortest) {\n      additionalClass = 'shortest';\n    }\n\n    return (\n      <div\n        className={`node ${additionalClass}`}\n        onMouseEnter={() => this.setState({ hover: true })}\n        onMouseLeave={() => this.setState({ hover: false })}\n        onMouseDown={() => this.props.onMouseDown(row, col)}\n        onMouseUp={() => this.props.onMouseUp(row, col)}\n      ></div>\n    );\n  }\n}\n","export function getNeighbors(grid, row, col) {\n  let neighbors = [];\n\n  const getValOrUndefined = (row, col) =>\n    row < 0 || row >= grid.length || col < 0 || col >= grid[0].length\n      ? undefined\n      : grid[row][col];\n\n  neighbors.push(getValOrUndefined(row + 1, col));\n  neighbors.push(getValOrUndefined(row - 1, col));\n  neighbors.push(getValOrUndefined(row, col + 1));\n  neighbors.push(getValOrUndefined(row, col - 1));\n\n  return neighbors.filter(node => node !== undefined);\n}\n\nexport function getShortestPath(grid, endNode) {\n  let path = [];\n  let currNode = grid[endNode.row][endNode.col];\n\n  while (currNode.parent !== undefined) {\n    path.unshift(currNode.parent);\n    currNode = currNode.parent;\n  }\n\n  path.push(grid[endNode.row][endNode.col]);\n  return path;\n}\n","import React, { Component } from 'react';\nimport Node from './Node/Node';\n\nimport { dijkstraPath } from '../Algorithms/Dijkstra';\nimport { dfsPath } from '../Algorithms/DFS';\nimport { bfsPath } from '../Algorithms/BFS';\n\nconst searchAlgorithms = {\n  dij: dijkstraPath,\n  dfs: dfsPath,\n  bfs: bfsPath\n};\nconst initState = {\n  width: 15,\n  height: 15,\n  grid: [],\n  draggingStart: false,\n  draggingEnd: false,\n  draggingWall: false,\n  startNode: { row: 0, col: 0 },\n  endNode: { row: 4, col: 7 }\n};\n\nexport default class PathFindingVisualizer extends Component {\n  constructor(props) {\n    super(props);\n\n    this.startNode = props.startNode;\n    this.endNode = props.endNode;\n\n    this.state = {\n      ...initState,\n      selectedAlgorithm: props.algo\n    };\n  }\n\n  componentDidMount() {\n    let grid = this.getInitialGrid({});\n    this.setState({ grid });\n  }\n\n  createNode(data) {\n    return {\n      ...data,\n      val: data.row + data.col,\n      visited: false,\n      distance: Infinity,\n      parent: undefined,\n      isStart: false,\n      isEnd: false\n    };\n  }\n\n  getGrid() {\n    return this.state.grid;\n  }\n\n  animateSolution(searchResult, grid) {\n    for (let i = 0; i < searchResult.path.length; i++) {\n      setTimeout(() => {\n        console.log('callin');\n        let currNode = searchResult.path[i];\n        let newGrid = grid.slice();\n        newGrid[currNode.row][currNode.col].shortest = true;\n        this.setState({ grid: newGrid });\n      }, i * 70);\n    }\n  }\n\n  executeSearch(algo) {\n    let { grid, startNode, endNode } = this.state;\n    let searchResult = searchAlgorithms[algo](startNode, endNode, grid);\n\n    for (let i = 0; i < searchResult.visited.length; i++) {\n      setTimeout(() => {\n        let currNode = searchResult.visited[i];\n        let newGrid = grid.slice();\n        newGrid[currNode.row][currNode.col].color = true;\n        this.setState({ grid: newGrid });\n        if (i === searchResult.visited.length - 1) {\n          this.animateSolution(searchResult, grid);\n        }\n      }, i * 30);\n    }\n  }\n\n  getInitialGrid(walls) {\n    let grid = [];\n    for (let row = 0; row < this.state.width; row++) {\n      let currNodes = [];\n      for (let col = 0; col < this.state.height; col++) {\n        currNodes.push(this.createNode({ row, col }));\n      }\n      grid.push(currNodes);\n    }\n    return grid;\n  }\n\n  mouseDown(inputRow, inputCol) {\n    const { startNode, endNode } = this.state;\n    if (inputRow === startNode.row && inputCol == startNode.col) {\n      this.setState({ draggingStart: true });\n    } else if (inputRow === endNode.row && inputCol == endNode.col) {\n      this.setState({ draggingEnd: true });\n    } else {\n      this.setState({ draggingWall: true });\n    }\n  }\n\n  mouseUp(row, col) {\n    const { startNode, endNode } = this.state;\n    if (this.state.draggingStart) {\n      this.setState({ draggingStart: false });\n      let startNode = {\n        row,\n        col\n      };\n      this.setState({ startNode });\n    } else if (this.state.draggingEnd) {\n      this.setState({ draggingEnd: false });\n      let endNode = {\n        row,\n        col\n      };\n      this.setState({ endNode });\n    } else {\n      this.setState({ draggingWall: false });\n    }\n  }\n\n  reset() {\n    let grid = this.getInitialGrid({});\n    this.setState({\n      ...initState,\n      grid,\n      selectedAlgorithm: this.state.selectedAlgorithm\n    });\n  }\n\n  render() {\n    const { startNode, endNode } = this.state;\n\n    const startRow = startNode.row;\n    const startCol = startNode.col;\n    const endRow = endNode.row;\n    const endCol = endNode.col;\n\n    return (\n      <div>\n        <select\n          onChange={selectedAlgorithm => {\n            this.setState({\n              selectedAlgorithm: selectedAlgorithm.target.value\n            });\n          }}\n          value={this.state.selectedAlgorithm}\n        >\n          {Object.keys(searchAlgorithms).map(key => {\n            return <option value={key}>{key}</option>;\n          })}\n        </select>\n        <button\n          onClick={() => this.executeSearch(this.state.selectedAlgorithm)}\n        >\n          Visualize Path\n        </button>\n        <button onClick={() => this.reset()}>Reset</button>\n        <div\n          style={{\n            width: 750,\n            height: 750,\n            border: '1px solid black',\n            margin: '0px auto',\n            marginTop: '10px'\n          }}\n        >\n          {this.state.grid.map((nodeRow, rowIdx) => {\n            return nodeRow.map((nodeCol, colIdx) => {\n              return (\n                <div>\n                  <Node\n                    row={rowIdx}\n                    key={rowIdx + colIdx}\n                    col={colIdx}\n                    grid={this.getGrid.bind(this)}\n                    onMouseDown={this.mouseDown.bind(this)}\n                    onMouseUp={this.mouseUp.bind(this)}\n                    isStart={startRow === rowIdx && startCol === colIdx}\n                    isEnd={endRow === rowIdx && endCol === colIdx}\n                    isHoveringStart={this.state.draggingStart}\n                    isHoveringEnd={this.state.draggingEnd}\n                    draggingWall={this.state.draggingWall}\n                  />{' '}\n                </div>\n              );\n            });\n          })}\n        </div>\n      </div>\n    );\n  }\n}\n","import { getNeighbors, getShortestPath } from './Util';\n\nexport function dijkstraPath(startNode, endNode, grid) {\n  const start = grid[startNode.row][startNode.col];\n  const end = grid[endNode.row][endNode.col];\n  start.distance = 0;\n\n  let unvisited = [start];\n  let visited = [];\n\n  while (unvisited.length > 0) {\n    let currNode = unvisited.shift();\n    currNode.visited = true;\n    visited.push(currNode);\n    if (currNode.row == end.row && currNode.col == end.col) break;\n    for (let node of getNeighbors(grid, currNode.row, currNode.col)) {\n      if (node.visited || node.isWall) continue;\n      let currDistance = currNode.distance + 1;\n      if (currDistance < node.distance) {\n        node.parent = currNode;\n        node.distance = currDistance;\n        unvisited.push(node);\n      }\n    }\n  }\n  return {\n    path: getShortestPath(grid, endNode),\n    visited\n  };\n}\n","import { getNeighbors, getShortestPath } from './Util';\n\nexport function dfsPath(startNode, endNode, grid) {\n  let stack = [];\n  let visited = [];\n  stack.push(grid[startNode.row][startNode.col]);\n\n  while (stack.length > 0) {\n    let currNode = stack.pop();\n    currNode.visited = true;\n    visited.push(currNode);\n    if (currNode.row == endNode.row && currNode.col == endNode.col) break;\n    let neighbors = getNeighbors(grid, currNode.row, currNode.col);\n    neighbors.forEach(neighbor => {\n      if (!neighbor.visited && !neighbor.isWall) {\n        neighbor.parent = currNode;\n        stack.push(neighbor);\n      }\n    });\n  }\n\n  return {\n    path: getShortestPath(grid, endNode),\n    visited\n  };\n}\n","import { getNeighbors, getShortestPath } from './Util';\n\nexport function bfsPath(startNode, endNode, grid) {\n  let start = grid[startNode.row][startNode.col];\n\n  let visited = [];\n  let end = grid[endNode.row][endNode.col];\n  let queue = [];\n  queue.push(start);\n\n  while (queue.length > 0) {\n    let currNode = queue.shift();\n    currNode.visited = true;\n    visited.push(currNode);\n\n    if (currNode.isWall) continue;\n    if (currNode.row == end.row && currNode.col == end.col) break;\n\n    const neighbors = getNeighbors(grid, currNode.row, currNode.col);\n\n    neighbors.forEach(neighbor => {\n      if (!neighbor.visited && !neighbor.isWall) {\n        neighbor.parent = currNode;\n        queue.push(neighbor);\n      }\n    });\n  }\n\n  return {\n    path: getShortestPath(grid, endNode),\n    visited\n  };\n}\n","import React from 'react';\nimport './App.css';\nimport PathFindingVisualizer from './PathFindingVisualizer/PathFindingVisualizer';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathFindingVisualizer startNode={0} endNode={0} algo={'dfs'} />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}